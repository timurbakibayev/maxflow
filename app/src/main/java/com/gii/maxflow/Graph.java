package com.gii.maxflow;

import android.graphics.Rect;

import java.util.ArrayList;

/**
 * Created by onion on 02.01.16.
 */
public class Graph {
    public float[][] AdjMatrix; //Adjacency Matrix of our Graph
    public ArrayList<GraphKnot> rootKnots = new ArrayList<>();
    public ArrayList<GraphKnot> allKnots = new ArrayList<>();
    public ArrayList<Circle> toDisplayList=new ArrayList<Circle>();  //contains objects that we want  to display currently
    public ArrayList<Rect> toDisplayListRect = new ArrayList<Rect>(); //contains rectangles in the enumeration list of the list above
    // this rectangles being generated by the plotList function
    public ArrayList<Circle> toHideList = new ArrayList<Circle>();         //defines list of temporarily invisible elements

    public float prevPieChartStrtAngle[];
    public float prevPieChartFinAngle[];
    public float currPieChartStrtAngle[];
    public float currPieChartFinAngle[];

    Graph()
    {
        super();
        allKnots=new ArrayList<GraphKnot>();
        rootKnots=new ArrayList<GraphKnot>();

    }

    Graph(Graph grph) {         //copy constructor
        int n;
            /*
            int n = grph.AdjMatrix.length;
            this.AdjMatrix = new float[n][n];
            for (int i=0; i<n; i++)
                for (int j=0; j<n; j++)
                    this.AdjMatrix[i][j] = grph.AdjMatrix[i][j];
            */
        if(grph.AdjMatrix!=null)
            this.AdjMatrix = grph.AdjMatrix.clone();

        n = grph.allKnots.size();
        this.allKnots = new ArrayList<GraphKnot>();
        for (int i = 0; i< n; i++) {
            //Log.d("message","index = "+i);
            this.allKnots.add(new GraphKnot(grph.allKnots.get(i)));
        }
        n = grph.rootKnots.size();
        this.rootKnots = new ArrayList<GraphKnot>();
        for (int i = 0; i< n; i++)
            this.rootKnots.add(new GraphKnot(grph.rootKnots.get(i)));

    }

    public boolean isInside(Circle circle){
        for (GraphKnot acc:allKnots)
            if(acc.knot.id.equals(circle.id))
                return true;
        return false;
    }

    public boolean isInside(GraphKnot knot){
        for (GraphKnot acc:allKnots)
            if(acc.knot.id.equals(knot.knot.id))
                return true;
        return false;
    }

    public boolean isInsideRootKnots(Circle circle){
        for (GraphKnot acc:rootKnots)
            if(acc.knot.id.equals(circle.id))
                return true;
        return false;
    }

    public boolean isInsideRootKnots(GraphKnot knot){
        for (GraphKnot acc:rootKnots)
            if(acc.knot.id.equals(knot.knot.id))
                return true;
        return false;
    }

    public int findKnotIndexById(String idToCheck){
        for (int i = 0; i < allKnots.size(); i++)
            if(allKnots.get(i).knot.id.equals(idToCheck))
                return i;
        return -1;
    }

    public int findRootKnotIndexById(String idToCheck){
        for (int i = 0; i < rootKnots.size(); i++)
            if(rootKnots.get(i).knot.id.equals(idToCheck))
                return i;
        return -1;
    }

    public void fillTheGraph(ArrayList<Circle> circle, ArrayList<Operation> displayedOperation, Properties properties,
                             int leftPage,int rightPage) {
        allKnots=new ArrayList<GraphKnot>();
        boolean newKnotAdded = false;
        for (Circle acc : circle )
            if (!isInside(acc) && acc.deleted==false) {   //if knot is not contained in the graph yet
                GraphKnot toAddKnot = new GraphKnot(acc);
                allKnots.add(toAddKnot);
                newKnotAdded=true;
            }

        int n=allKnots.size();

        //now define adjacency matrix
        if (newKnotAdded) {
            //Log.d("message", "have added a new knot " + newKnotAdded);
            AdjMatrix = new float[n][n];
        }
        for  (int i =0; i<n; i++)
            for  (int j =0; j<n; j++)
                AdjMatrix[i][j] = 0;
        for(Operation oper: displayedOperation ) {
            if (oper.pageNo>=leftPage && oper.pageNo<=rightPage){
                int indexFrom=findKnotIndexById(oper.fromCircle);
                int indexTo=findKnotIndexById(oper.toCircle);
                if(indexFrom!=-1 && indexTo!=-1)
                    AdjMatrix[indexFrom][indexTo] = AdjMatrix[indexFrom][indexTo]+oper.amount;
            }
        }

        //initialize rootKnots
        //at first find the very main root
        rootKnots=new ArrayList<GraphKnot>();
        float maxRootWeightsSum=0;
        int maxRootIndex=0;
        for (int i=0; i<n; i++) {
            float curSum=0;
            for (int j=0; j<n; j++)
                curSum=curSum+Math.abs(AdjMatrix[i][j])+Math.abs(AdjMatrix[j][i]);
            if(curSum>maxRootWeightsSum){
                maxRootIndex=i;
                maxRootWeightsSum=curSum;
            }
        }

        rootKnots.add(allKnots.get(maxRootIndex));

        for (int i=0; i<n; i++){
            int sum = 0;
            boolean incomingCircleExists=false;
            for(int j=0; j<n ; j++) {
                if(AdjMatrix[j][i]>0f) //it means an Circle (j,i) exists
                    incomingCircleExists=true;
            }
            if(!incomingCircleExists && !rootKnots.contains(allKnots.get(i)))
                rootKnots.add(allKnots.get(i));
        }
        if (rootKnots.size()==0)
            rootKnots.add(allKnots.get(0));

        if(prevPieChartStrtAngle==null || prevPieChartStrtAngle.length!=allKnots.size()) {
            n = allKnots.size();

            prevPieChartStrtAngle = new float[n];
            prevPieChartFinAngle = new float[n];
            currPieChartStrtAngle = new float[n];
            currPieChartFinAngle = new float[n];
        }
    }

    public void fillTheGraph(ArrayList<Circle> circle, ArrayList<Operation> displayedOperation, Properties properties) {
        allKnots=new ArrayList<GraphKnot>();
        boolean newKnotAdded = false;
        for (Circle acc : circle )
            if (!isInside(acc) && acc.deleted==false) {   //if knot is not contained in the graph yet
                GraphKnot toAddKnot = new GraphKnot(acc);
                allKnots.add(toAddKnot);
                newKnotAdded=true;
            }

        int n=allKnots.size();

        //now define adjacency matrix
        if (newKnotAdded) {
            //Log.d("message", "have added a new knot " + newKnotAdded);
            AdjMatrix = new float[n][n];
        }
        for  (int i =0; i<n; i++)
            for  (int j =0; j<n; j++)
                AdjMatrix[i][j] = 0;
        for(Operation oper: displayedOperation ) {
            if (true){
                int indexFrom=findKnotIndexById(oper.fromCircle);
                int indexTo=findKnotIndexById(oper.toCircle);
                if(indexFrom!=-1 && indexTo!=-1)
                    AdjMatrix[indexFrom][indexTo] = AdjMatrix[indexFrom][indexTo]+oper.amount;
            }
        }

        //initialize rootKnots
        //at first find the very main root
        rootKnots=new ArrayList<GraphKnot>();
        float maxRootWeightsSum=0;
        int maxRootIndex=0;
        for (int i=0; i<n; i++) {
            float curSum=0;
            for (int j=0; j<n; j++)
                curSum=curSum+Math.abs(AdjMatrix[i][j])+Math.abs(AdjMatrix[j][i]);
            if(curSum>maxRootWeightsSum){
                maxRootIndex=i;
                maxRootWeightsSum=curSum;
            }
        }

        rootKnots.add(allKnots.get(maxRootIndex));

        for (int i=0; i<n; i++){
            int sum = 0;
            boolean incomingCircleExists=false;
            for(int j=0; j<n ; j++) {
                if(AdjMatrix[j][i]>0f) //it means an Circle (j,i) exists
                    incomingCircleExists=true;
            }
            if(!incomingCircleExists && !rootKnots.contains(allKnots.get(i)))
                rootKnots.add(allKnots.get(i));
        }
        if (rootKnots.size()==0)
            rootKnots.add(allKnots.get(0));

        if(prevPieChartStrtAngle==null || prevPieChartStrtAngle.length!=allKnots.size()) {
            n = allKnots.size();

            prevPieChartStrtAngle = new float[n];
            prevPieChartFinAngle = new float[n];
            currPieChartStrtAngle = new float[n];
            currPieChartFinAngle = new float[n];
        }
    }

}