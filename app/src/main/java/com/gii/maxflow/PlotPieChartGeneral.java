package com.gii.maxflow;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BlurMaskFilter;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.PointF;
import android.graphics.Rect;
import android.support.annotation.NonNull;
import android.util.Log;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.View;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by onion on 28.12.15.
 */

public class PlotPieChartGeneral{
    public class GraphKnot {
        Circle knot = null;
        ArrayList<Circle> predecessor = new ArrayList<Circle>();
        ArrayList<Circle> successor = new ArrayList<Circle>();
        GraphKnot rootedAtKnot;  //defines a list, at which current knot is rooted in the List

        int toPlot;    //plot on chart, if equal 0 - not defined yet, 1 stays for plotting and -1 for concealed element
        int alreadyIndexedInList;
        int toDisplayInList; //to display in the List or to leave transparent
        int toExpand; //to expand adjoined elements in the List
        Rect toPlotRect; //Rectangle that's filled with color and indicates whether current knot is displayed on a chart
        Rect toExpandRect; //Rectangle that "contains" text written in the List
        float toPlotValue;
        int colorIndex;


        public GraphKnot(GraphKnot knt){            //copy constuctor
            //this.knot = new Circle(knt.knot);
            if(knt!=null) {
                if (knt.knot != null)
                    this.knot = new Circle(knt.knot);
                //this.knot=knt.knot;
                //this.predecessor = new ArrayList<Circle>(knt.predecessor);
                //this.successor = new ArrayList<Circle>(knt.successor);


                this.rootedAtKnot = new GraphKnot(knt.rootedAtKnot);

                this.toPlot = knt.toPlot;
                this.alreadyIndexedInList = knt.alreadyIndexedInList;
                this.toDisplayInList = knt.toDisplayInList;
                this.toExpand = knt.toExpand;
                this.toPlotRect = knt.toPlotRect;
                this.toExpandRect = knt.toExpandRect;
                this.toPlotValue = knt.toPlotValue;
                this.colorIndex = knt.colorIndex;
            }
            else
                ;

        }


        public GraphKnot(Circle crc) {
            this.knot = crc;
            this.toPlot=1;
            this.alreadyIndexedInList=0;
            this.toExpand=1;
            this.toDisplayInList=1;
            this.toPlotValue=0;
            this.colorIndex=-1;
        }

        public boolean hasPredecessor(String crc){
            for (Circle acc:predecessor)
                if(acc.id == crc)
                    return true;
            return false;
        }
        public boolean hasPredecessor(Circle crc){
            for (Circle acc:predecessor)
                if(acc.id == crc.id)
                    return true;
            return false;
        }
        public boolean hasPredecessor(GraphKnot crc){
            for (Circle acc:predecessor)
                if(acc.id == crc.knot.id)
                    return true;
            return false;
        }
        public boolean hasSuccessor(String crc){
            for (Circle acc:successor)
                if(acc.id == crc)
                    return true;
            return false;
        }
        public boolean hasSuccessor(Circle crc){
            for (Circle acc:successor)
                if(acc.id == crc.id)
                    return true;
            return false;
        }
        public boolean hasSuccessor(GraphKnot crc){
            for (Circle acc:successor)
                if(acc.id == crc.knot.id)
                    return true;
            return false;
        }
    }

    public class Graph {
        public float[][] AdjMatrix; //Adjacency Matrix of our Graph
        public ArrayList<GraphKnot> rootKnots = new ArrayList<>();
        public ArrayList<GraphKnot> allKnots = new ArrayList<>();
        public ArrayList<Circle> toDisplayList=new ArrayList<Circle>();  //contains objects that we want  to display currently
        public ArrayList<Rect> toDisplayListRect = new ArrayList<Rect>(); //contains rectangles in the enumeration list of the list above
        // this rectangles being generated by the plotList function
        public ArrayList<Circle> toHideList = new ArrayList<Circle>();         //defines list of temporarily invisible elements

        Graph()
        {
            super();
            allKnots=new ArrayList<GraphKnot>();
            rootKnots=new ArrayList<GraphKnot>();

        }

        Graph(Graph grph) {         //copy constructor
            int n;
            /*
            int n = grph.AdjMatrix.length;
            this.AdjMatrix = new float[n][n];
            for (int i=0; i<n; i++)
                for (int j=0; j<n; j++)
                    this.AdjMatrix[i][j] = grph.AdjMatrix[i][j];
            */
            if(grph.AdjMatrix!=null)
                this.AdjMatrix = grph.AdjMatrix.clone();

            n = grph.allKnots.size();
            this.allKnots = new ArrayList<GraphKnot>();
            for (int i = 0; i< n; i++) {
                //Log.d("message","index = "+i);
                this.allKnots.add(new GraphKnot(grph.allKnots.get(i)));
            }
            n = grph.rootKnots.size();
            this.rootKnots = new ArrayList<GraphKnot>();
            for (int i = 0; i< n; i++)
                this.rootKnots.add(new GraphKnot(grph.rootKnots.get(i)));

        }

        public boolean isInside(Circle circle){
            for (GraphKnot acc:allKnots)
                if(acc.knot.id == circle.id)
                    return true;
            return false;
        }

        public boolean isInside(GraphKnot knot){
            for (GraphKnot acc:allKnots)
                if(acc.knot.id == knot.knot.id)
                    return true;
            return false;
        }

        public boolean isInsideRootKnots(Circle circle){
            for (GraphKnot acc:rootKnots)
                if(acc.knot.id == circle.id)
                    return true;
            return false;
        }

        public boolean isInsideRootKnots(GraphKnot knot){
            for (GraphKnot acc:rootKnots)
                if(acc.knot.id == knot.knot.id)
                    return true;
            return false;
        }

        public int findKnotIndexById(String idToCheck){
            for (int i = 0; i < allKnots.size(); i++)
                if(allKnots.get(i).knot.id.equals(idToCheck))
                    return i;
            return -1;
        }

        public int findRootKnotIndexById(String idToCheck){
            for (int i = 0; i < rootKnots.size(); i++)
                if(rootKnots.get(i).knot.id.equals(idToCheck))
                    return i;
            return -1;
        }

        public void fillTheGraph(ArrayList<Circle> circle, ArrayList<Operation> displayedOperation, Properties properties) {
            allKnots=new ArrayList<GraphKnot>();
            boolean newKnotAdded = false;
            for (Circle acc : circle )
                if (!isInside(acc) && acc.deleted==false) {   //if knot is not contained in the graph yet
                    GraphKnot toAddKnot = new GraphKnot(acc);
                    /* We will need this for future optimization
                    //now check for outcoming adjacency with recently created knot
                    for (int j = 0; j < displayedOperation.size(); j++) {

                        if (displayedOperation.get(j).fromCircle.equals(acc.id))
                            //now let's find circle in the list "circle" by its id
                            for (int i = 0; i < circle.size(); i++)
                                if (circle.get(i).id.equals(acc.id))
                                    toAddKnot.successor.add(circle.get(i));  //add successor

                        //now check for incoming adjacency with recently created knot
                        if (displayedOperation.get(j).toCircle.equals(acc.id))
                            //now let's find circle in the list "circle" by its id
                            for (int i = 0; i < circle.size(); i++)
                                if (circle.get(i).id.equals(acc.id))
                                    toAddKnot.successor.add(circle.get(i));  //add successor

                    }
                    */
                    allKnots.add(toAddKnot);
                    newKnotAdded=true;
                }

            int n=allKnots.size();

            //now define adjacency matrix
            if (newKnotAdded) {
                //Log.d("message", "have added a new knot " + newKnotAdded);
                AdjMatrix = new float[n][n];
            }
            for  (int i =0; i<n; i++)
                for  (int j =0; j<n; j++)
                    AdjMatrix[i][j] = 0;
            for(Operation oper: displayedOperation ) {
                if (true){
                    int indexFrom=findKnotIndexById(oper.fromCircle);
                    int indexTo=findKnotIndexById(oper.toCircle);
                    if(indexFrom!=-1 && indexTo!=-1)
                        AdjMatrix[indexFrom][indexTo] = AdjMatrix[indexFrom][indexTo]+oper.amount;
                }
            }

            //initialize rootKnots
            //at first find the very main root
            rootKnots=new ArrayList<GraphKnot>();
            float maxRootWeightsSum=0;
            int maxRootIndex=0;
            for (int i=0; i<n; i++) {
                float curSum=0;
                for (int j=0; j<n; j++)
                    curSum=curSum+Math.abs(AdjMatrix[i][j])+Math.abs(AdjMatrix[j][i]);
                if(curSum>maxRootWeightsSum){
                    maxRootIndex=i;
                    maxRootWeightsSum=curSum;
                }
            }

            rootKnots.add(allKnots.get(maxRootIndex));

            for (int i=0; i<n; i++){
                int sum = 0;
                boolean incomingCircleExists=false;
                for(int j=0; j<n ; j++) {
                    if(AdjMatrix[j][i]>0f) //it means an Circle (j,i) exists
                        incomingCircleExists=true;
                }
                if(!incomingCircleExists && !rootKnots.contains(allKnots.get(i)))
                    rootKnots.add(allKnots.get(i));
            }
            if (rootKnots.size()==0)
                rootKnots.add(allKnots.get(0));

        }

    }

    Canvas canvas;
    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    int[] listOfColors={Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.BLACK, Color.WHITE, Color.CYAN, Color.DKGRAY};
    Graph graph=new Graph();

    public float prevPieChartStrtAngle[];
    public float prevPieChartFinAngle[];
    public float currPieChartStrtAngle[];
    public float currPieChartFinAngle[];


    private int toPlotListTopOffset=30;
    int toDrawPortion=0; //redraw parameter, responsible for smoothness of drawing diagramms. It shows
    // what a percentage of our chart we want to draw right now. It varies from 0 to maxDrawPortion
    private static final int maxDrawPortion=20;
    private static int       drawPortionSpeed=1;

    private float scaleFactor;
    private PointF backgroundPosition = new PointF(0, 0);
    float generalListScrolledPosition;
    private PointF lastBackgroundPosition = new PointF(0,0);
    private PointF canvasMovingStartingPoint = new PointF(0,0);

    public boolean onTouchEventChartMode(@NonNull MotionEvent event, GII.AppState appState) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                canvasMovingStartingPoint = new PointF((int) event.getX(), (int) event.getY());
                lastBackgroundPosition = backgroundPosition;


                //now check for pressing rectangle icon in a list

                for (GraphKnot acc: graph.allKnots) {
                    //Log.d("message","angle of a sector related to " + acc.knot.name+ " varies from " + currPieChartStrtAngle[graph.allKnots.indexOf(acc)]
                    //+ " to " + currPieChartFinAngle[graph.allKnots.indexOf(acc)]);
                    if (acc.toPlotRect.contains((int) event.getX(), (int) event.getY())) {
                        if(!graph.toHideList.contains(acc.knot)) {
                            graph.toHideList.add(acc.knot);
                            toDrawPortion = 0;
                        }
                        else {
                            graph.toHideList.remove(acc.knot);
                            toDrawPortion = 0;
                        }
                    }
                }
                break;
            case MotionEvent.ACTION_MOVE:
                backgroundPosition = new PointF((int) (lastBackgroundPosition.x + (canvasMovingStartingPoint.x - event.getX())),
                        (int) (lastBackgroundPosition.y + (canvasMovingStartingPoint.y - event.getY())));
                backgroundPosition.y = Math.min(backgroundPosition.y, (graph.allKnots.size()-3)*40);//(int)((graph.allKnots.size())*40*1.4)-420 + 30 );
                backgroundPosition.y = Math.max(backgroundPosition.y, 0);// -(int)((graph.allKnots.size())*40*1.4)+30+420);
                generalListScrolledPosition=backgroundPosition.y;
                break;
            case MotionEvent.ACTION_UP:
                break;
            default:
                return false;
        }
        return true;
    }

    public boolean onScale(ScaleGestureDetector detector, GII.AppState appState) {
        scaleFactor *= detector.getScaleFactor();
        scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 4));
        if (scaleFactor <= 0.1f)
            appState = GII.AppState.idle;
        return true;
    }


    public void generateColors(int n) {
        listOfColors= new int[n];
        for (int i = 0; i<n; i++ ) {
            double t=(double)i/(double)n;
            int r = 0;
            int g = 0;
            int b = 0;

            if( t >= 0.0/6.0   && t < 1.0/6.0) {r = (int)255; g = (int)0; b = (int)(0 + (t-0.0)*6*255); }
            if( t >= 1.0/6.0   && t < 2.0/6.0) {b = (int)255; g = (int)0; r = (int)(255 - (t-1.0/6.0)*6*255); }
            if( t >= 2.0/6.0   && t < 3.0/6.0) {b = (int)255; r = (int)0; g = (int)(0 + (t-2.0/6.0)*6*255); }
            if( t >= 3.0/6.0   && t < 4.0/6.0) {g = (int)255; r = (int)0; b = (int)(255 - (t-3.0/6.0)*6*255); }
            if( t >= 4.0/6.0   && t < 5.0/6.0) {g = (int)255; b = (int)0; r = (int) (0 + (t - 4.0 / 6.0) * 6 * 255);
            }
            if( t >= 5.0/6.0   && t <= 6.0/6.0){r = (int)255; b = (int)0; g = (int)(255 - (t-5.0/6.0)*6*255); }
            listOfColors[i] = Color.rgb((int)((float)r*0.9),(int)((float)g*0.9),(int)((float)b*0.9));
        }
    }

    public  PlotPieChartGeneral() {
    }
    public PlotPieChartGeneral(Canvas canv) {
        super();

        canvas = canv;

        paint.setColor(Color.BLUE);
        paint.setStyle(Paint.Style.FILL_AND_STROKE);
    }


    public boolean onTouchEvent(MotionEvent ev) {
        // Let the ScaleGestureDetector inspect all events.
        //mScaleDetector.onTouchEvent(ev);
        final float x = ev.getX();
        final float y = ev.getY();
        return true;
    }

    public void plot(Canvas canvas_orig, GII.AppState appState, Properties properties, ArrayList<Circle> circle, ArrayList<Operation> displayedOperation) {
        graph.fillTheGraph(circle, displayedOperation, properties);
        generateColors(graph.allKnots.size());
        for (int i=0; i< listOfColors.length; i++)
            graph.allKnots.get(i).colorIndex=listOfColors[i];

        graph.toDisplayList=new ArrayList<Circle>();
        graph.toDisplayListRect = new ArrayList<Rect>();
        //Bitmap returnArrow = BitmapFactory.decodeResource(getResources(),R.drawable.arrow_bw,);
        //drawReturnButton
        //canvas_orig.drawBitmap(returnArrow,new Rect(0,0, returnArrow.getWidth(),returnArrow.getHeight()), returnArrowRect,null);

        if(prevPieChartStrtAngle==null || prevPieChartStrtAngle.length!=graph.allKnots.size()) {
            int n = graph.allKnots.size();

            prevPieChartStrtAngle = new float[n];
            prevPieChartFinAngle = new float[n];
            currPieChartStrtAngle = new float[n];
            currPieChartFinAngle = new float[n];
        }

        //Create Config file for Bitmaps, hell knows what's the purpose of this, but whatever
        Bitmap.Config toBlurBitmapConf = Bitmap.Config.ARGB_8888;


        //plotting list with names and corresponding colors
        Bitmap bitmapList = Bitmap.createBitmap(420,420,toBlurBitmapConf);
        Canvas canvasList = new Canvas(bitmapList);
        plotList(canvasList, appState, circle, displayedOperation);


        //Bitmap and canvas for the first pieOutput chart
        Bitmap toBlurBitmap1 = Bitmap.createBitmap(420,420,toBlurBitmapConf);
        Canvas canvas1= new Canvas(toBlurBitmap1);

        //Bitmap and canvas for a general pieOutput chart
        Bitmap toBlurBitmap2 = Bitmap.createBitmap(420,420,toBlurBitmapConf);
        Canvas canvas2= new Canvas(toBlurBitmap2);

        paint.setStyle(Paint.Style.FILL);
        paint.setMaskFilter(new BlurMaskFilter(1, BlurMaskFilter.Blur.NORMAL));

        toDrawPortion=Math.min(toDrawPortion+drawPortionSpeed,maxDrawPortion);
        //increase redrawing area
        if (toDrawPortion<maxDrawPortion)
            toDrawPortion=Math.min(toDrawPortion + drawPortionSpeed, maxDrawPortion);
        else
            for (int i = 0; i<graph.allKnots.size(); i++) {
                prevPieChartStrtAngle[i] = currPieChartStrtAngle[i];
                prevPieChartFinAngle[i] = currPieChartFinAngle[i];
            }
        //if(toDrawPortion>=maxDrawPortion-1)

        //generate list of objects we're interested in currently
        for (Circle acc : circle)
            if (acc.amount!=0 && !graph.toDisplayList.contains(acc))
                graph.toDisplayList.add(acc);

        //here we paint pieOutput chart for each month
        PlotPieChartGeneralSpecifically(canvas1, graph.toDisplayList, displayedOperation);

        //here we're blurring our Pie charts, an adornment merely. However we're avoiding thus
        //an antialiasing effect
        canvas_orig.drawBitmap(toBlurBitmap1,300,100,paint);
        canvas_orig.drawBitmap(bitmapList,1,1,paint);
    }

    private void plotList(Canvas canvas, GII.AppState appState, ArrayList<Circle> circle, ArrayList<Operation> displayedOperation){
        int xOffset = 40;
        int yOffset = 30;
        int rectCircle = 40;
        int totalSum = 0;
        toPlotListTopOffset=60;
        int amountNonZeroCircles=0;
        for (Circle acc : circle )
            if (acc.amount != 0) {
                totalSum += Math.abs(acc.amount);
                amountNonZeroCircles=amountNonZeroCircles+1;
            }
        generateColors(graph.allKnots.size());
        for (GraphKnot acc : graph.rootKnots)
            plotListRecursively(canvas, acc.knot, xOffset, circle,displayedOperation);
    }

    private void plotListRecursively(Canvas canvas, Circle currCircle,int horOffset, ArrayList<Circle> circle, ArrayList<Operation> displayedOperation){
        int rectCircle = 40;
        int k = 0;
        int currCircleIndex = 0;
        int yOffset = toPlotListTopOffset - (int)generalListScrolledPosition;

        if (graph.findKnotIndexById(currCircle.id)!=-1)
            currCircleIndex = graph.findKnotIndexById(currCircle.id);
        else
            return;
        graph.allKnots.get(currCircleIndex).alreadyIndexedInList=1;
        graph.allKnots.get(currCircleIndex).toPlotRect = new Rect(horOffset, yOffset - rectCircle,
                horOffset + rectCircle, yOffset);

        paint.setColor(graph.allKnots.get(currCircleIndex).colorIndex);
        if (graph.toHideList.contains(graph.allKnots.get(currCircleIndex).knot))
            paint.setAlpha(30);
        canvas.drawRect(horOffset, yOffset - rectCircle, horOffset + rectCircle, yOffset, paint);
        paint.setAlpha(255);
        paint.setTextSize((int) (rectCircle * 1.0));
        paint.setColor(Color.BLACK);
        canvas.drawText(currCircle.name, horOffset + (int)(rectCircle * 1.1), yOffset, paint);
        toPlotListTopOffset=toPlotListTopOffset+(int)(rectCircle*1.4);

        for (int j=0; j<graph.allKnots.size(); j++) {
            //now we find, so to say, main parent for an element j
            int maxIndexForJ=0;
            float maxWeightForJ=0f;
            for (int i = 0; i < graph.allKnots.size(); i++)
                if (graph.AdjMatrix[i][j] - graph.AdjMatrix[j][i] > maxWeightForJ ) {
                    maxWeightForJ = graph.AdjMatrix[i][j] - graph.AdjMatrix[j][i];
                    maxIndexForJ=i;
                }
            if (maxIndexForJ==currCircleIndex && maxWeightForJ>0f && graph.allKnots.get(j).alreadyIndexedInList==0) {
                plotListRecursively(canvas, graph.allKnots.get(j).knot, horOffset + (int)(rectCircle*0.8) , circle, displayedOperation);
            }
        }
    }

    private void PlotPieChartGeneralSpecifically(Canvas canvas, ArrayList<Circle> circle, ArrayList<Operation> displayedOperation)
    {
        int totalSum = 0;
        int amountNonZeroCircles=0;
        for (GraphKnot acc: graph.allKnots)
            if (acc.toPlot != 0 && !graph.toHideList.contains(acc.knot)) {
                acc.toPlotValue=0;
                for (Operation opr:displayedOperation) {
                    if(opr.toCircle==acc.knot.id)   //here we may add another condition to verify operation
                        // lies in a specific region of interest
                        acc.toPlotValue=acc.toPlotValue+opr.amount;
                    if(opr.fromCircle==acc.knot.id) //here we may add another condition to verify operation
                        // lies in a specific region of interest
                        acc.toPlotValue=acc.toPlotValue-opr.amount;

                }
                totalSum += Math.abs(acc.toPlotValue);
                if(totalSum>0);
                amountNonZeroCircles=amountNonZeroCircles+1;
            }
        //generateColors(amountNonZeroCircles);

        float curAngle = 0f;
        float toAddAngle = 0f;
        int k = 0;

        //calculate coordinates of the pieOutput
        for (GraphKnot acc : graph.allKnots) {
            currPieChartStrtAngle[graph.allKnots.indexOf(acc)]=curAngle;
            toAddAngle = 360.0f * Math.abs(acc.toPlotValue) / (float)totalSum;
            if (acc.toPlot == 1 && !graph.toHideList.contains(acc.knot))
                curAngle = curAngle + toAddAngle;
            currPieChartFinAngle[graph.allKnots.indexOf(acc)] = curAngle;
        }

        float t = (float)toDrawPortion / (float)maxDrawPortion;
        t=(float)Math.sin(3.1415*((double)t-0.5))/2.0f+0.5f;
        t=t*t;
        for (GraphKnot acc : graph.allKnots)
            if (acc.toPlotValue != 0 && !graph.toHideList.contains(acc.knot) || true) {
                paint.setColor(acc.colorIndex);
                if(acc.toPlot==1 || true) {

                    int ind = graph.allKnots.indexOf(acc);
                    canvas.drawArc(10, 10, 410, 410, prevPieChartStrtAngle[ind] * (1 - t) + currPieChartStrtAngle[ind] * t,//30*t
                            prevPieChartFinAngle[ind] * (1 - t) + currPieChartFinAngle[ind] * t - prevPieChartStrtAngle[ind] * (1 - t) - currPieChartStrtAngle[ind] * t
                            , true, paint);

                }

            }

        paint.setColor(Color.GRAY);
        paint.setColor(Color.rgb(240,240,240));
        canvas.drawArc(150, 150, 270, 270, 0, 360, true, paint);
    };

    //requires certain modifications
    private void PlotPieChartGeneralGeneral(Canvas canvas, ArrayList<Circle> circle)
    {
        int totalSum = 0;
        int amountNonZeroCircles=0;
        for (Circle acc : circle)
            if (acc.amountTotal != 0) {
                totalSum += Math.abs(acc.amountTotal);
                amountNonZeroCircles=amountNonZeroCircles+1;
            }
        generateColors(amountNonZeroCircles);

        float curAngle = 0;
        int k = 0;
        for (Circle acc : circle)
            if (acc.amountTotal != 0 && listOfColors.length>0) {
                paint.setColor(listOfColors[k % listOfColors.length]);
                k = k + 1;
                canvas.drawArc(10, 10, 210, 210, curAngle, (Math.abs(acc.amountTotal) / totalSum) * 360, true, paint);
                curAngle = curAngle + (Math.abs(acc.amountTotal) / totalSum) * 360;

            }
        //paint.setColor(Color.WHITE);
        paint.setColor(Color.rgb(240,240,240));
        canvas.drawArc(90, 90, 130, 130, 0, 360, true, paint);
    };

    public int returnClickResult(PointF point) {
        //now we check whether any object from our list was pressed.
        int index= 0;
        for (Rect rect : graph.toDisplayListRect) {
            if (rect.contains((int)point.x, (int)point.y)) {
                toDrawPortion=0;
                if(!graph.toHideList.contains(graph.toDisplayList.get(index)))
                    graph.toHideList.add(graph.toDisplayList.get(index));
                else
                    graph.toHideList.remove(graph.toDisplayList.get(index));
            }
            index=index+1;
        }
        return 0;
    }

    public void plotTimeLine(Canvas canvas){
        int barWidthBy2=10;
        int barHeightBy2=20;
        canvas.drawLine(400,600,700,600,paint);

        canvas.drawRect(400-barWidthBy2,600-barHeightBy2,600+barWidthBy2,600+barHeightBy2, paint);
        canvas.drawRect(700-barWidthBy2,600-barHeightBy2,700+barWidthBy2,600+barHeightBy2, paint);
    }

}